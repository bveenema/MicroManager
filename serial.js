// Module Imports
const { ipcMain } = require('electron')
const RealSerialPort = require('serialport')
const MockSerialPort = require('./mockSerialPort')
let SerialPort = RealSerialPort
const Readline = require('@serialport/parser-readline')

// Local Imports
const MicroDebugWindow = require('./windows/micro-debug/micro-debug')
const MainWindow = require('./windows/main/main')

let port = null
const WRITE_INTERVAL = 10 //ms
let WriteBuffer = {
  LastCommand: '',
  Writeable: true,
  Writes: [],
  OutstandingCommand: null,
  OutsandingCallback: null,
  WriteTimer: null,

  // Write
  // Attempts to write the next command to the device.
  // Writes are only allowed every WRITE_INTERVAL after a write is acknowledged by the device
  Write: function(){
    // If Writeable, write the object and set not Writeable
    if(this.Writeable){
      this.Writeable = false
      // write to the serial port
      let wObj = this.Writes.shift()
      port.write(wObj.command + ':' + wObj.value)

      // Set the outstanding values
      this.OutstandingCommand = wObj.command
      this.OutsandingCallback = wObj.callback
    
    // Otherwise delay and check again if there are still Writes in the buffer
    }else if(this.Writes.length > 0 && this.WriteTimer === null){
      this.WriteTimer = setTimeout(function(){ 
        this.WriteTimer = null
        this.Write()
      }.bind(this), 2)
    }
  },

  // Handle Acknowledge
  Acknowledge: function(returnVal) {
    // Reset Oustanding Command and call the callback
    this.OutstandingCommand = null
    this.OutsandingCallback(returnVal)

    // Delay next write for WRITE_INTERVAL
    setTimeout(function(){ this.Writeable = true }.bind(this), WRITE_INTERVAL)
  },
}


// Handle Write
ipcMain.on('serial:write', (e, command, value) => {
  // Add to the write buffer
  WriteBuffer.Writes.push({
    command: command, 
    value: value,
    callback: function(returnVal){
      e.reply('serial:wrote', command, returnVal)
    }
  })
  WriteBuffer.Write()
})


// Open
// Attempts to open the specified port. Returns resolve if successful
// \param[obj] device - device object (generated by)
function Open(device){
  return new Promise((resolve, reject) => {
    // Close any open port
    if(port){
      console.log('closing the open port')
      port.close((err) => {
        if(err) reject()

        // reset ready and configured
        ready = false
        configured = false

        OpenPort(device).then(() => {
          console.log('closed')
          resolve()
        }).catch(() => {
          console.log('failed to close')
          reject()
        })
      })
    }else{
      OpenPort(device).then(() => {
        resolve()
      }).catch(() => {
        console.log('Catching OpenPort reject')
        reject()
      })
    }
  })
}

function HandleConfig(configObj) {
  if(configObj.baud){
    port.update({
      baudRate: configObj.baud
    })
  }
  if(configObj.settings){
    MainWindow.LoadSettings(configObj.settings)
    MainWindow.LoadState(configObj.state)
  }
}

function OpenPort(device){
  return new Promise((resolve, reject) => {
    // Open the port
    port = new SerialPort(device.comName, {
      // no options
    })

    // Attach a newline parser
    const parser = port.pipe(new Readline({ delimiter: '\r\n' }))

    // Handle Incoming Data
    parser.on('data', (data) => {
      // split the data string at the first colon, into keyword and value
      let [keyWord, value] = data.split(/:(.+)/)
      let command = parseInt(keyWord)
      // Handle 'READY' keyword
      if(keyWord === 'READY'){
        port.write('CONFIG')
      
      // Handle 'CONFIG' return
      }else if(keyWord === 'CONFIG'){
        let config = JSON.parse(value)
        HandleConfig(config)
        resolve()
      
      // Handle debug messages
      }else if(command === 0){
        MicroDebugWindow.Update(value)
      
      // Handle command messages
      }else if(command !== NaN){
        MainWindow.Update(command, value)
        // Handle write acknowledges
        if(command === WriteBuffer.OutstandingCommand)
          WriteBuffer.Acknowledge(value)
      }
      
    })

    // Handle open
    port.on('open', () => {
      console.log('Open')
    })

    // Handle error
    port.on('error', () => {
      console.log('Error')
      reject()
    })
  })
}

// Handle serial open
ipcMain.on('serial:open', (e, device) => {
  Open(device).then(() => {
    e.reply('serial:opened', true)
  }).catch(() => {
    console.log('Failed to Open')
  })
})

module.exports = {
  GetDevices: function(){
    return new Promise((resolve, reject) => {
      SerialPort.list().then((ports) =>{
        console.log(ports)
        resolve(ports)
        ports.forEach((port) => {
          console.log("----- Port -----\n", port)
        })
      }, (err) => {
        console.error(err)
      })
    })
  },

  UpdateMockSerial: function(){
    if(process.useMockMicros)
      SerialPort = MockSerialPort
    else
      SerialPort = RealSerialPort
  }
}